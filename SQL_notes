SQL 

-- single line comment
/* comments for multiple lines, not read */ 

SELECT <what as alias>
FROM <table>
LIMIT <#>


'string'
`string not to be confused with SQL command` -- such as a column called `from`


-- filtering, go row by row to find where statement is true
WHERE <condition> -- ex: WHERE id = 145 (boolean), name = 'Ray'

NOT, AND, OR -- in order of precedence, or use () to specify order

<column> LIKE '%roy' -- anything before, must end with 'roy'
<column> LIKE 'roy%' -- must start with 'roy', end with anything
<column> LIKE '_roy' -- 1 wildcard char before exact end


--- NESTING ---
Find the first and last name of the the inmate with the 
longest last statement (by character count).

SELECT first_name, last_name
FROM executions
WHERE LENGTH(last_statement) = /* returns a number to compare to in the main query */
    (select max(length(last_statement)) 
				from executions)


Calc percentage of executions per county using a nested query that delivers the total count of executions
SELECT
  county,
  100.0 * COUNT(*) / (select count(*) from executions)
    AS percentage
FROM executions
GROUP BY county
ORDER BY percentage DESC

*** JOINS
Aggregations produce a smaller table
Row operations limit to information already in the rows
JOINS will be required to bring in additional information(such as date sinec last execution)
Joins create a big combined table that is then fed into the FROM block

Format: <table1> JOIN <table2> ON <clause>

INNER (default) - unmatched rows are dropped
LEFT - preserve all rows of left table, empty parts become NULL
RIGHT - see above
OUTER - preserve all empty/unmatched rows in both tables

duplicates: if one row in table A matches 2+ rows in table B, JOIN will produce
copy of A to match B so there will be two A-B rows (each gets its own partner),
leading to duplicates

--Suppose we have tableA with 3 rows and tableB with 5 rows.--
tableA JOIN tableB ON 1 returns 15 rows.
The ON 1 clause is always true, so every row of tableA is matched against every row of tableB.

tableA JOIN tableB ON 0 returns 0 rows.
For the same reason that ON 1 returns 15 rows.

tableA LEFT JOIN tableB ON 0 returns 3 rows.
The left join preserves all the rows of tableA even though no rows of tableB match.

tableA OUTER JOIN tableB ON 0 returns 8 rows.
The outer join preserves all the rows of tableA and tableB even though none of them are paired.

tableA OUTER JOIN tableB ON 1 returns 15 rows.
All the rows of tableA match all of the rows of tableB because of the on 1 clause, 
so any join will return 15 rows. The different joins only differ in how they handle unmatched rows.

**** DATES in SQLite
Compute the current date.

SELECT date('now');
Compute the last day of the current month.

SELECT date('now','start of month','+1 month','-1 day');
Compute the date and time given a unix timestamp 1092941466.

SELECT datetime(1092941466, 'unixepoch');
Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone.

SELECT datetime(1092941466, 'unixepoch', 'localtime');
Compute the current unix timestamp.

SELECT strftime('%s','now');
Compute the number of days since the signing of the US Declaration of Independence.

SELECT julianday('now') - julianday('1776-07-04');
Compute the number of seconds since a particular moment in 2004:

SELECT strftime('%s','now') - strftime('%s','2004-01-01 02:34:56');
Compute the date of the first Tuesday in October for the current year.

SELECT date('now','start of year','+9 months','weekday 2');
Compute the time since the unix epoch in seconds (like strftime('%s','now') except includes fractional part):

SELECT (julianday('now') - 2440587.5)*86400.0;

# build 'previous ex date' table:
# shift ex number forward so that when joined with executions, 
# the 'last_ex_date' is for the previous ex
SELECT
  ex_number + 1 AS ex_number,
  ex_date AS last_ex_date
FROM executions
WHERE ex_number < 553 # limit of num_exs +1

## Self join (previous is derived from executions) - powerful for rows to get information from other parts of the same table
## use the above CTE named 'previous' table to in join with OG, limit 10 largest 
SELECT
  last_ex_date AS start,
  ex_date AS end,
  JULIANDAY(ex_date) - JULIANDAY(last_ex_date)
    AS day_difference
FROM executions
JOIN (SELECT
  ex_number + 1 AS ex_number,
  ex_date AS last_ex_date
FROM executions
WHERE ex_number < 553) previous
  ON executions.ex_number = previous.ex_number
ORDER BY day_difference DESC
LIMIT 10

# this particular CTE can be condensed significantly, 
note the ON clause can include the shift number and still alias the "second" (self) tables
SELECT
  previous.ex_date AS start,
  executions.ex_date AS end,
  JULIANDAY(executions.ex_date) - JULIANDAY(previous.ex_date)
    AS day_difference
FROM executions
JOIN executions previous
  ON executions.ex_number = previous.ex_number + 1
ORDER BY day_difference DESC
LIMIT 10





**** MODE SQL ****
The idea is that each row is one data point or observation, and all the information contained in that row belongs together.

Can use ><= with alphetbetical (such as months)

you can only perform arithmetic across columns on values in a given row

To clarify, you can only add values in multiple columns from the same row together using +
if you want to add values across multiple rows, you'll need to use aggregate functions.

columns that contain the arithmetic functions are called "derived columns"

** left off on logical operators



















**** then try this: https://assessment.datacamp.com/data-analysis-in-sql?utm_source=linkedin&utm_medium=social&utm_campaign=fy21_q1_signal_data_analysis_sql
https://www.interviewquery.com/blog-sql-interview-questions/
SQL on hacker rank!

Advanced challenges:
https://selectstarsql.com/questions.html#challenge_questions